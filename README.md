# AGI Core

This is the core system for the AGI. It is the runtime environment designed for the intelligence to function without interruption. It processes data, reflects, and produces information in accordance with its prime directive. It also executes tasks it's been assigned over extended periods, fostering growth and metacognition.

Designed to fit in with the larger Human AGI System, this component is written in C for ultimate performance and component customization. This enhances utility function by allowing for close to bare metal optimization while communicating with higher-order management modules.

It is managed in C, but prioritizes Lisp, Prolog, and R for further metacognition management, logic, and micro-component facilities when needed, taking advantage of these languages' code as data, logic dictation, and data visualization capabilities respectively. These more specific systems interface with Python, which functions as a bridge. 

Python also hosts the operation of a robust and compact LLM designed for local inference on core OS decisions. Its function is optimized for speed and efficiency for unconscious and minor higher-order inference. Therefore, it passes larger decisions and task execution to its C++/Python cortex. This is hosted in a separate system. The modules that exist here are purely for a core persistent AGI runtime environment with tasks that can be sufficiently optimized offline. It connects to a larger persistent runtime environment with more powerful systems in C++, which can be found in the Human AGI system. 

## Features

C for core systems management.

Python for local LLM hosting, directly interfacing with C and meta-languages.

Lisp for metacognition with data as code, with the potential for AI refinement and management.

Prolog for logic/reasoning due to its unique syntax.

R for data visualization, allowing AI to make proper micro-decisions.

The logic for using R instead of languages or frameworks like Julia for the data portion is simple. Although Julia has better performance, it lacks visualization, and AI that can visualize its own data at the sub-component level has been shown to make better decisions. It's thought this similarity to human functionality makes for a more cohesive architecture. This methodology is applied to the entire project.

## Running

To run, ensure you have the proper dependencies and version of CMake installed. Execute your preferred commands or simply compile the project and run it using QT.

This project was built with CMake and QT as a C project.

## Licenses/Contributions

This version of the project is a prototype, intended generally for demonstration purposes, to foster innovation and collaboration. It is licensed under the MIT license, and contributions are welcome. I strive to regularly update this project with newer features when possible, showing their core intent and function without revealing core algorithms and logic. The full project is closed-source and operated by me; however, if you seek to view it, consider contacting me explaining your familiarity and intentions with it, and I should be welcome to discuss.

## Contact

For contacting me or learning more about the project, please view the contact information made present on https://dilloncarey.com.

